= {sqlpp} Queries from the SDK
:description: You can query for documents in Couchbase using the {sqlpp} query language (formerly N1QL), a language based on SQL, but designed for structured and flexible JSON documents.
:navtitle: {sqlpp} from the SDK
:page-topic-type: howto
:page-aliases: ROOT:n1ql-queries,ROOT:n1ql-queries-with-sdk

include::project-docs:partial$attributes.adoc[]

[abstract]
{description}
Querying can solve typical programming tasks such as finding a user profile by email address, facebook login, or user ID.

Our query service uses {sqlpp}, which will be fairly familiar to anyone who's used any dialect of SQL.
xref:#additional-resources[Further resources] for learning about {sqlpp} are listed at the bottom of the page.
Before you get started you may wish to checkout the
xref:{version-server}@server:n1ql:n1ql-language-reference/index.adoc[{sqlpp} intro page], or just dive in with a query against our "travel-sample" data set.
In this case, note that before you can query a bucket, you must define at least one index.
You can define a _primary_ index on a bucket.
When a primary index is defined you can issue non-covered queries on the bucket as well.

Use
xref:{version-server}@server::tools/cbq-shell.html[cbq], our interactive Query shell.
Open it, and enter the following:

[source,n1ql]
----
CREATE PRIMARY INDEX ON `travel-sample`
----

or replace _travel-sample_ with a different Bucket name to build an index on a different dataset.

NOTE: The default installation places cbq in `/opt/couchbase/bin/` on Linux, `/Applications/Couchbase Server.app/Contents/Resources/couchbase-core/bin/cbq` on OS X, and `C:\Program Files\Couchbase\Server\bin\cbq.exe` on Microsoft Windows.

== Getting Started

After familiarizing yourself with the basics on how the {sqlpp} query language works and how to query it from the UI you can use it from the Python SDK. Here's a complete example of doing a query and handling the results:

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=n1ql_basic_example]
----

NOTE: When using a Couchbase version < 6.5 you must create a valid Bucket connection using `cluster.bucket(name)` before you can use {sqlpp}.

Let's break it down. A query is always performed at the `Cluster` level, using the `query` method. It takes the statement as a required argument and then allows to provide additional options if needed.


Once a result returns you can iterate the returned rows and/or access the `QueryMetaData` associated with the query.


== Queries & Placeholders

Placeholders allow you to specify variable constraints for an otherwise constant query.
There are two variants of placeholders: postional and named parameters.
Positional parameters use an ordinal placeholder for substitution and named parameters use variables.
A named or positional parameter is a placeholder for a value in the WHERE, LIMIT or OFFSET clause of a query.
Note that both parameters and options are optional.

.Positional parameter example:
[source,python]
----
include::howtos:example$n1ql_ops.py[tag=positional]
----

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=positional_options]
----

.Named parameter example:
[source,python]
----
include::howtos:example$n1ql_ops.py[tag=named_kwargs]
----

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=named_options]
----

The complete code for this page's example can be found at https://github.com/couchbase/docs-sdk-python/blob/release/3.2/modules/howtos/examples/n1ql_ops.py[n1ql_ops.py].
What style you choose is up to you, for readability in more complex queries we generally recommend using the named parameters.
Note that you cannot use parameters in all positions.
If you put it in an unsupported place the server will respond with a `ParsingFailedException` or similar.

== The Query Result

When performing a query, the response you receive is a `QueryResult`.
If no error is returned then the request succeeded and the result provides access to both the rows returned and also associated `QueryMetaData`.

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=iterating]
----

The `QueryMetaData` provides insight into some basic profiling/timing information as well as information like the `ClientContextID`.

.QueryMetaData
[options="header"]
|====
| Name       | Description
| `request_id() -> str` | Returns the request identifer of this request.
| `client_context_id() -> str` | Returns the context ID either generated by the SDK or supplied by the user.
| `status() -> QueryStatus` | An enum simply representing the state of the result.
| `metrics() -> Optional[QueryMetrics]` | Returns metrics provided by the query for the request if enabled.
| `signature() -> Optional[JSON]` | If a signature is present, it will be available to consume in a generic fashion.
| `warnings() -> List[QueryWarning]` | Non-fatal errors are available to consume as warnings on this method.
| `profile() -> Optional[JSON]` | If enabled returns additional profiling information of the query.
|====

For example, here is how you can print the `executionTime` of a query:

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=print_metrics]
----

== Query Options
The query service provides an array of options to customize your query. The following table lists them all:

.Available Query Options
[options="header"]
|====
| Name       | Description
| `client_context_id (str)` | Sets a context ID returned by the service for debugging purposes.
| `positional_parameters (Iterable[JSON])` | Allows to set positional arguments for a parameterized query.
| `named_parameters (dict[str,JSON])` | Allows to set named arguments for a parameterized query.
| `priority(boolean)` | Assigns a different server-side priority to the query.
| `raw (dict[str,JSON])` | Escape hatch to add arguments that are not covered by these options.
| `read_only (bool)` | Tells the client and server that this query is readonly.
| `adhoc (bool)` | If set to false will prepare the query and later execute the prepared statement.
| `consistent_with (MutationState)` | Allows to be consistent with previously written mutations ("read your own writes").
| `max_parallelism (int)` | Tunes the maximum parallelism on the server.
| `metrics (bool)` | Enables the server to send metrics back to the client as part of the response.
| `pipeline_batch (int)` | Sets the batch size for the query pipeline.
| `pipeline_cap (int)` | Sets the cap for the query pipeline.
| `profile (QueryProfile)` | Allows to enable additional query profiling as part of the response.
| `scan_wait (timedelta)` | Allows to specify a maximum scan wait time.
| `scan_cap (int)` | Specifies a maximum cap on the query scan size.
| `scan_consistency (QueryScanConsistency)` | Sets a different scan consistency for this query.
| `query_context` | Allows to set target bucket and/or scope.
|====


== Scan Consistency

By default, the query engine will return whatever is currently in the index at the time of query (this mode is also called `QueryScanConsistency.NOT_BOUNDED`).
If you need to include everything that has just been written, a different scan consistency must be chosen.
If `QueryScanConsistency.REQUEST_PLUS` is chosen, it will likely take a bit longer to return the results but the query engine will make sure that it is as up-to-date as possible.

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=scan_consistency]
----

You can also use `consistent_with=MutationState` for a more narrowed-down scan consistency.
Construct the `MutationState` from individual `MutationToken`s that are returned from KV `MutationResult`s to make sure at least those mutations are visible.
Depending on the index update rate this might provide a speedier response.

// Due to https://issues.couchbase.com/browse/MB-46876 this section wonâ€™t work with named scopes and collections,
// we need to omit this information until Couchbase Server 7.0.1 is available, which will contain the fix for this bug.
// We should avoid showing the user this information until then.

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=ryow]
----

=== Client Context ID

The SDK will always send a client context ID with each query, even if none is provided by the user.
By default a UUID will be generated that is mirrored back from the query engine and can be used for debugging purposes.
A custom string can always be provided if you want to introduce application-specific semantics into it (so that for example in a network dump it shows up with a certain identifier).
Whatever is chosen, we recommend making sure it is unique so different queries can be distinguished during debugging or monitoring.

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=client_context_id]
----

=== ReadOnly

If the query is marked as readonly, both the server and the SDK can improve processing of the operation.
On the client side, the SDK can be more liberal with retries because it can be sure that there are no state-mutating side-effects happening.
The query engine will ensure that actually no data is mutated when parsing and planning the query.

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=read_only]
----

////
TODO:  can provide once transcoders/serializers are available w/in SDK

=== Custom JSON Serializer

Like with all JSON apis, it is possible to customize the JSON serializer. It allows to plug in your own library. This in turn makes it possible to serialize rows into PODs or other structures that your application defines and the SDK has no idea about.

Please see the documentation transcoding and serialization for more information.
////

== Streaming Large Result Sets

By default, the Python SDK will stream the result set from the server, where the client will start a persistent connection with the server and only read the header until the Rows are enumerated; then, each row or JSON object will be de-serialized one at a time.

This decreases pressure on Garbage Collection and helps to prevent OutOfMemory errors.

== Async APIs

In addition to the blocking API on `Cluster`, the SDK provides asyncio and Twisted APIs on `ACluster` or `TxCluster` respectively.
If you are in doubt of which API to use, we recommend looking at the asyncio API first.

Simple queries with both asyncio and Twisted APIs look similar to the blocking one:

.ACouchbase
[source,python]
----
include::howtos:example$acouchbase_n1ql_ops.py[tag=simple_query]
----

.TxCouchbase
[source,python]
----
include::howtos:example$txcouchbase_n1ql_ops.py[tag=simple_query]
----

== Querying at Scope Level

It is possible to query off the xref:concept-docs:n1ql-query.adoc#collections-and-scopes-and-the-query-context[`Scope` level],
_with Couchbase Server release 7.0_, using the `scope.query()` method.
It takes the statement as a required argument, and then allows additional options if needed.

[source,python]
----
include::howtos:example$n1ql_ops.py[tag=scope]
----

== Additional Resources

NOTE: {sqlpp} is not the only query option in Couchbase.
Be sure to check that xref:concept-docs:http-services.adoc[your use case fits your selection of query service].

* For a deeper dive into {sqlpp} from the SDK, refer to our xref:concept-docs:n1ql-query.adoc[{sqlpp} SDK concept doc].
* The xref:{version-server}@server:n1ql:n1ql-language-reference/index.adoc[Server doc {sqlpp} intro] introduces a complete guide to the {sqlpp} language, including all of the latest additions.
* The http://query.pub.couchbase.com/tutorial/#1[{sqlpp} interactive tutorial] is a good introduction to the basics of {sqlpp} use.
* For scaling up queries, be sure to
xref:{version-server}@server:n1ql:n1ql-language-reference/index.adoc[read up on Indexes].
* The Query Service is for operational queries; for analytical workloads, read more on xref:concept-docs:http-services.adoc#Long-Running-Queries-&-Big-Data[when to choose Analytics Service].

